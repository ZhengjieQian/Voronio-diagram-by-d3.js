<!DOCTYPE html>
<html>
<head>
    <title>Voronoi Diagram with D3.js</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        /* Add some CSS styling if needed */
        .cell {
            fill: none;
            stroke: #000;
            stroke-opacity: 0.5;
        }
        .point-label {
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
        .cell-area {
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
    </style>
</head>
<body>
<svg width="800" height="500"></svg>
<div id="point-values" style="position: absolute; top: 10px; right: 100px;"></div>

<script>
    // Initialize the points array with 10 random points and values
    const numPoints = 10;
    const points = [];
    for (let i = 0; i < numPoints; i++) {
        const x = Math.random() * 500;
        const y = Math.random() * 500;
        const value = Math.floor(Math.random() * 11); // Random value from 0 to 10
        points.push({ x, y, value });
    }

    // Function to calculate the value of a point using a natural neighbor algorithm
    function natural_neighbor(x, y) {
        return 12; // Replace with your own algorithm.
    }



/*    function natural_neighbor(x, y) {
        // Calculate the sum
        let sum = 0;

        // Iterate through each point in the array
        for (const point of points) {
            // Calculate the original and current values
            const originalValue = point.value;
            const currentValue = Math.floor(Math.random() * 11); // Replace with your own algorithm for current value calculation

            // Calculate the sum for this point
            const pointSum = ((originalValue - currentValue) / originalValue) * point.value;

            // Add the point's contribution to the sum
            sum += pointSum;
        }

        // Round the sum to two decimal places
        const roundedSum = sum.toFixed(2);

        // Return the total sum as a string with two decimal places
        return parseFloat(roundedSum);
    }*/

    // Create a Voronoi generator
    const voronoi = d3.voronoi()
        .extent([[-1, -1], [800 + 1, 500 + 1]]);

    // Array to store original cell areas
    const originalCellAreas = [];

    // Function to calculate the area of a polygon using the Shoelace formula
    function calculatePolygonArea(polygon) {
        return 0.5 * Math.abs(d3.polygonArea(polygon));
    }

    // Function to redraw the Voronoi diagram and display point values
    function redraw() {
        // Generate the Voronoi diagram
        const polygons = voronoi.polygons(points.map(point => [point.x, point.y]));

        // Remove existing cells, points, and area labels
        svg.selectAll(".cell").remove();
        svg.selectAll(".point").remove();
        svg.selectAll(".cell-area").remove();

        // Draw Voronoi cells and calculate and display cell areas
        polygons.forEach((polygon, index) => {
            if (polygon) {
                // Calculate the area of the polygon using the Shoelace formula
                const currentArea = calculatePolygonArea(polygon);
                const originalArea = originalCellAreas[index] || currentArea; // Get the original area or use current area

                // Display the cell area as a label
                svg.append("text")
                    .attr("class", "cell-area")
                    .attr("x", d3.mean(polygon, d => d[0]))
                    .attr("y", d3.mean(polygon, d => d[1]))
                    .text(`Original Area: ${originalArea.toFixed(2)}, Current Area: ${currentArea.toFixed(2)}`)
                    .style("font-size", "12px");

                // Store the current area as the original area for the next redraw
                originalCellAreas[index] = currentArea;

                // Draw Voronoi cell
                svg.append("path")
                    .attr("class", "cell")
                    .attr("d", "M" + polygon.join("L") + "Z");
            }
        });

        // Draw points with values
        svg.selectAll(".point")
            .data(points)
            .enter().append("circle")
            .attr("class", "point")
            .attr("r", 4)
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("fill", d3.interpolateViridis(d => d.value / 10)); // Color based on value;

        // Display point values
        const pointValuesDiv = document.getElementById("point-values");
        pointValuesDiv.innerHTML = "";
        points.forEach((point, index) => {
            const label = document.createElement("div");
            label.className = "point-label";
            label.textContent = `Point ${index + 1}: Value ${point.value}`;
            pointValuesDiv.appendChild(label);
        });
    }

    // Create an SVG element
    const svg = d3.select("svg");

    // Redraw the diagram initially
    redraw();

    // Add click event listener to the SVG
    svg.on("click", function() {
        // Get the mouse coordinates
        const [x, y] = d3.mouse(this);

        // Calculate the value using the natural_neighbor function
        const value = natural_neighbor(x, y);

        // Add the new point with the calculated value to the array
        points.push({ x, y, value });

        // Redraw the diagram with the new point
        redraw();
    });
</script>
</body>
</html>
