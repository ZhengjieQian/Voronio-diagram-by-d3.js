<!DOCTYPE html>
<html>
<head>
    <title>Voronoi Diagram with D3.js</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        /* Add some CSS styling if needed */
        .cell {
            fill: none;
            stroke: #000;
            stroke-opacity: 0.5;
        }
        .point-label {
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
        .cell-area {
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
    </style>
</head>
<body>
<svg width="800" height="500"></svg>
<div id="point-values" style="position: absolute; top: 10px; right: 100px;"></div>

<script>
    // Initialize the points array with 10 random points and values
    let answer = 0;
    const numPoints = 10;
    const points = [];
    for (let i = 0; i < numPoints; i++) {
        const x = Math.random() * 500;
        const y = Math.random() * 500;
        const value = Math.floor(Math.random() * 11); // Random value from 0 to 10
        points.push({ x, y, value });
    }

    // Create a Voronoi generator
    const voronoi = d3.voronoi()
        .extent([[-1, -1], [800 + 1, 500 + 1]]);

    // Array to store original cell areas
    const originalCellAreas = [];

    // Function to redraw the Voronoi diagram and display point values
    function redraw() {
        // Generate the Voronoi diagram
        const polygons = voronoi.polygons(points.map(point => [point.x, point.y]));

        // Remove existing cells and points
        svg.selectAll(".cell").remove();
        svg.selectAll(".point").remove();

        // Create an array to store the cell areas
        const cellAreas = [];

        // Draw Voronoi cells
        polygons.forEach((polygon, index) => {
            if (polygon) {
                // Calculate the area of the polygon using the Shoelace formula
                const currentArea = 0.5 * Math.abs(d3.polygonArea(polygon));
                const originalArea = originalCellAreas[index] || currentArea;
                const value = ((originalArea - currentArea) / originalArea) * points[index].value;
                answer += value;

                // Draw Voronoi cell
                svg.append("path")
                    .attr("class", "cell")
                    .attr("d", "M" + polygon.join("L") + "Z");

                // Store the current area as the original area for the next redraw
                originalCellAreas[index] = currentArea;

                // Store the current cell area
                cellAreas.push({ originalArea, currentArea });

                // Draw each existing point as yellow
                svg.append("circle")
                    .attr("class", "point")
                    .attr("r", 4)
                    .attr("cx", points[index].x)
                    .attr("cy", points[index].y)
                    .attr("fill", "yellow");

                // Add point number above the point
                svg.append("text")
                    .attr("class", "point-label")
                    .attr("x", points[index].x)
                    .attr("y", points[index].y - 10)
                    .text(index + 1);

                // Draw the added point as red
                if (index === points.length - 1) {
                    svg.append("circle")
                        .attr("class", "point")
                        .attr("r", 4)
                        .attr("cx", points[index].x)
                        .attr("cy", points[index].y)
                        .attr("fill", "red");

                    // Add point number above the added point
                    svg.append("text")
                        .attr("class", "point-label")
                        .attr("x", points[index].x)
                        .attr("y", points[index].y - 10)
                        .text(index + 1);
                }
            }
        });
        console.log(answer+"the log here is for check")
        answer = 0;
        const pointValuesDiv = document.getElementById("point-values");
        pointValuesDiv.innerHTML = "";

        cellAreas.forEach((area, index) => {
            const label = document.createElement("div");
            label.className = "point-label";

            label.textContent = `Point ${index + 1}: Original Area ${area.originalArea.toFixed(2)}, Current Area ${area.currentArea.toFixed(2)}, Value ${points[index].value}`;
            area.originalArea = area.currentArea; //Restore the original area value
            pointValuesDiv.appendChild(label);
        });
    }

    // Create an SVG element
    const svg = d3.select("svg");

    // Redraw the diagram initially
    redraw();

    // Add click event listener to the SVG
    svg.on("click", function() {
        // Get the mouse coordinates
        const [x, y] = d3.mouse(this);

        // Add the new point to the array with an initial temporary value
        const newPoint = { x, y, value: 0 };

        // Push the new point to the array
        points.push(newPoint);

        // Calculate the value for the new point
        newPoint.value = calculateNewPointValue(newPoint);

        // Redraw the diagram with the new point
        redraw();
    });

    // Function to calculate the value for the new point
    function calculateNewPointValue(newPoint) {
        let newPointValue = 0;

        // Iterate through existing points and calculate the value for the new point
        for (let i = 0; i < points.length - 1; i++) {
            const currentArea = 0.5 * Math.abs(d3.polygonArea(voronoi.polygons(points.map(point => [point.x, point.y]))[i]));
            newPointValue += (originalCellAreas[i] - currentArea) / originalCellAreas[i] * points[i].value;
        }

        return newPointValue;
    }
</script>
</body>
</html>
